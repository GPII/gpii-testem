{
  "version": 3,
  "sources": [
    "/Users/duhrer/Source/rtf/gpii-testem/src/js/instrumenter.js"
  ],
  "names": [
    "fluid",
    "require",
    "gpii",
    "registerNamespace",
    "fs",
    "path",
    "mkdirp",
    "glob",
    "istanbul",
    "testem",
    "instrumenter",
    "defaultOptions",
    "sources",
    "excludes",
    "nonSources",
    "istanbulOptions",
    "produceSourceMap",
    "autoWrap",
    "instrument",
    "inputPath",
    "outputPath",
    "instrumentationOptions",
    "promises",
    "resolvedInputPath",
    "resolveFluidModulePathSafely",
    "resolvedOutputPath",
    "mergePolicy",
    "combinedInstrumentationOptions",
    "merge",
    "sourceFileWrappedPromise",
    "promise",
    "push",
    "sourcesToExclude",
    "concat",
    "sourceFilePromise",
    "findFilesMatchingFilter",
    "then",
    "filesToInstrument",
    "instrumentationPromise",
    "instrumentAllFiles",
    "resolve",
    "reject",
    "nonSourceWrappedPromise",
    "nonSourcePromise",
    "filesToCopy",
    "fileCopyPromise",
    "copyAllFiles",
    "sequence",
    "combinePositivePatterns",
    "patterns",
    "inversePatterns",
    "positivePatterns",
    "makeArray",
    "filter",
    "pattern",
    "indexOf",
    "negativeInversePatterns",
    "inversePattern",
    "positiveInversePatterns",
    "map",
    "inverseWithExclamation",
    "substring",
    "baseInputPath",
    "positiveRules",
    "negativeRules",
    "negativePatterns",
    "options",
    "cwd",
    "ignore",
    "nodir",
    "each",
    "singlePositivePattern",
    "singlePatternPromise",
    "error",
    "files",
    "results",
    "flatten",
    "baseOutputPath",
    "resolvedBaseInputPath",
    "module",
    "resolvePath",
    "resolvedBaseOutputPath",
    "createInstrumenter",
    "relativePath",
    "instrumentationOuterPromise",
    "singleFilePromises",
    "outputDir",
    "dirname",
    "existsSync",
    "sync",
    "source",
    "readFileSync",
    "instrumentedSource",
    "instrumentSync",
    "instrumentedFileWritePromise",
    "writeFile",
    "sourceMap",
    "lastSourceMap",
    "sourceMapPath",
    "sourceMapWritePromise",
    "JSON",
    "stringify",
    "singleFileSequence",
    "log",
    "fullInputPath",
    "readStream",
    "createReadStream",
    "writeStream",
    "createWriteStream",
    "on",
    "pipe",
    "err"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/*\n\n    A static function to \"instrument\" a source repository.  Uses the same instrumentation library as `nyc`, but\n    avoids common problems with including \"node_modules\" content as we do in our larger projects.\n\n */\n/* eslint-env node */\n\"use strict\";\nvar fluid     = require(\"infusion\");\nvar gpii      = fluid.registerNamespace(\"gpii\");\nvar fs        = require(\"fs\");\nvar path      = require(\"path\");\nvar mkdirp    = require(\"mkdirp\");\nvar glob      = require(\"glob\");\n\nvar istanbul = require(\"istanbul-lib-instrument\");\n\nrequire(\"./lib/resolveSafely\");\n\nfluid.registerNamespace(\"gpii.testem.instrumenter\");\n\n// The default options.  See the instrumenter docs for details.\ngpii.testem.instrumenter.defaultOptions = {\n    sources:    [\"./**/*.js\"],\n    excludes:   [\"./node_modules/**/*\", \"./.git/**/*\", \"./reports/**/*\", \"./coverage/**/*\", \"./.idea/**/*\", \"./.vagrant/**/*\", \"tests/**/*\", \"./instrumented/**/*\"],\n    nonSources: [\"./**/*.!(js)\", \"./Gruntfile.js\"],\n    istanbulOptions: {\n        produceSourceMap: true,\n        autoWrap: true\n    }\n};\n\n/**\n *\n * Instrument the code found at `inputPath` and save the results to `outputPath`.\n *\n * @param {String} inputPath - The full or package-relative path to a directory containing code to instrument.\n * @param {String} outputPath - The full or package-relative path to the directory where you want to save the instrumented output.\n * @param {Object} instrumentationOptions - Configuration options to control what is instrumented.  See the instrumenter docs for details.\n * @return {Promise} - A `fluid.promise` that will be resolved when the full instrumentation is complete or rejected if there is an error at any point.\n *\n */\ngpii.testem.instrumenter.instrument = function (inputPath, outputPath, instrumentationOptions) {\n    var promises = [];\n\n    var resolvedInputPath  = gpii.testem.resolveFluidModulePathSafely(inputPath);\n    var resolvedOutputPath = gpii.testem.resolveFluidModulePathSafely(outputPath);\n\n    // User-supplied patterns should completely replace the originals.\n    var mergePolicy = {\n        sources: \"replace\",\n        excludes: \"replace\",\n        nonSources: \"replace\"\n    };\n\n    var combinedInstrumentationOptions = fluid.merge(mergePolicy, gpii.testem.instrumenter.defaultOptions, instrumentationOptions || {});\n\n    // Instrument files that are part of our \"sources\" pattern, but which are not defined as excluded or non-sources.\n    var sourceFileWrappedPromise = fluid.promise();\n    promises.push(sourceFileWrappedPromise);\n    var sourcesToExclude = combinedInstrumentationOptions.excludes.concat(combinedInstrumentationOptions.nonSources);\n    var sourceFilePromise = gpii.testem.instrumenter.findFilesMatchingFilter(resolvedInputPath, combinedInstrumentationOptions.sources, sourcesToExclude);\n    sourceFilePromise.then(\n        function (filesToInstrument) {\n            var instrumentationPromise = gpii.testem.instrumenter.instrumentAllFiles(filesToInstrument, inputPath, resolvedOutputPath, combinedInstrumentationOptions);\n            instrumentationPromise.then(sourceFileWrappedPromise.resolve, sourceFileWrappedPromise.reject);\n        },\n        sourceFileWrappedPromise.reject\n    );\n\n    // Copy \"non source\" files which are not excluded.\n    var nonSourceWrappedPromise = fluid.promise();\n    promises.push(nonSourceWrappedPromise);\n    var nonSourcePromise = gpii.testem.instrumenter.findFilesMatchingFilter(resolvedInputPath, combinedInstrumentationOptions.nonSources, combinedInstrumentationOptions.excludes);\n    nonSourcePromise.then(\n        function (filesToCopy) {\n            var fileCopyPromise = gpii.testem.instrumenter.copyAllFiles(filesToCopy, inputPath, resolvedOutputPath);\n            fileCopyPromise.then(nonSourceWrappedPromise.resolve, nonSourceWrappedPromise.reject);\n        },\n        nonSourceWrappedPromise.reject\n    );\n\n    var sequence = fluid.promise.sequence(promises);\n    return sequence;\n};\n\n/**\n *\n * The library we use for matching (node-glob) does not support \"negated\" patterns.  This function standardises\n * \"negative\" patterns so that we can use them with node-glob and perform a single comparison pass. It combines the\n * non-negated patterns from `patterns` with \"negative\" patterns from `inversePatterns`, minus their leading exclamation\n * point.  So:\n *\n * gpii.testem.instrumenter.combinePositivePatterns([\"onePos\", \"!oneNeg\"], [\"twoPos\", \"!twoNeg\"]);\n *\n * Outputs: `[\"onePos\", \"twoPos\"]`\n *\n * @param {Array} patterns - An array of minimatch patterns representing one state (inclusion, for example).\n * @param {Array} inversePatterns - An array of minimatch patterns representing the opposite state (exclusion, for example).\n * @return {Array} - An array representing all \"positive\" matches (see above).\n *\n */\ngpii.testem.instrumenter.combinePositivePatterns = function (patterns, inversePatterns) {\n    var positivePatterns = fluid.makeArray(patterns).filter(function (pattern)  { return pattern.indexOf(\"!\") !== 0; });\n    var negativeInversePatterns = fluid.makeArray(inversePatterns).filter(function (inversePattern) { return inversePattern.indexOf(\"!\") === 0; });\n    var positiveInversePatterns = negativeInversePatterns.map(function (inverseWithExclamation) { return inverseWithExclamation.substring(1); });\n    return positivePatterns.concat(positiveInversePatterns);\n};\n\n/**\n *\n * Test a given file path against two sets of rules, one \"positive\" (material that should be included), and one\n * \"negative\" (material that should be excluded).  Used to determine whether to include a file in our instrumented\n * output, and also to determine whether it should be instrumented or copied.\n *\n * @param {String} baseInputPath - The full path to the base \"input\" directory that `filePath` is relative to.\n * @param {Array} positiveRules - A list of minimatch patterns to include, relative to `baseInputPath`.\n * @param {Array} negativeRules - A list of minimatch patterns to exclude, relative to `baseInputPath`.\n * @return {Promise} - A `fluid.promise` that will be resolved with a list of matching paths, relative to `baseInputPath`, or rejected if there is an error.\n *\n */\ngpii.testem.instrumenter.findFilesMatchingFilter = function (baseInputPath, positiveRules, negativeRules) {\n    var promise = fluid.promise();\n    var positivePatterns = gpii.testem.instrumenter.combinePositivePatterns(positiveRules, negativeRules);\n    var negativePatterns = gpii.testem.instrumenter.combinePositivePatterns(negativeRules, positiveRules);\n\n    // See https://github.com/isaacs/node-glob#options\n    var options = {\n        cwd: baseInputPath,\n        ignore: negativePatterns,\n        // Our approach very much depends on only having files, and NOT directories.  Remove this at your peril.\n        nodir: true\n    };\n    var promises = [];\n    fluid.each(positivePatterns, function (singlePositivePattern) {\n        var singlePatternPromise = fluid.promise();\n        promises.push(singlePatternPromise);\n        glob(singlePositivePattern, options, function (error, files) {\n            if (error) {\n                singlePatternPromise.reject(error);\n            }\n            else {\n                singlePatternPromise.resolve(files);\n            }\n        });\n    });\n    var sequence = fluid.promise.sequence(promises);\n    sequence.then(\n        function (results) {\n            promise.resolve(fluid.flatten(results));\n        },\n        promise.reject\n    );\n    return promise;\n};\n\n/**\n *\n * Instrument a list of files.\n *\n * @param {Array} filesToInstrument - An array of paths to files that should be instrumented, relative to `baseInputPath`.\n * @param {String} baseInputPath - The full path to the base \"input\" directory.\n * @param {String} baseOutputPath - The full path to the base \"output\" directory.\n * @param {Object} instrumentationOptions - Configuration options to control what is instrumented.  See the instrumenter docs for details.\n * @return {Promise} - A `fluid.promise` that will be resolved when all files are instrumented, or rejected if there is an error.\n *\n */\ngpii.testem.instrumenter.instrumentAllFiles = function (filesToInstrument, baseInputPath, baseOutputPath, instrumentationOptions) {\n    var resolvedBaseInputPath = fluid.module.resolvePath(baseInputPath);\n    var resolvedBaseOutputPath = fluid.module.resolvePath(baseOutputPath);\n    var instrumenter = istanbul.createInstrumenter(instrumentationOptions.istanbulOptions);\n\n    var promises = [];\n    fluid.each(filesToInstrument, function (relativePath) {\n        promises.push(function () {\n            var instrumentationOuterPromise = fluid.promise();\n\n            var singleFilePromises = [];\n            var inputPath = path.resolve(resolvedBaseInputPath, relativePath);\n            var outputPath = path.resolve(resolvedBaseOutputPath, relativePath);\n            var outputDir = path.dirname(outputPath);\n            try {\n                if (!fs.existsSync(outputDir)) {\n                    mkdirp.sync(outputDir);\n                }\n                var source = fs.readFileSync(inputPath, \"utf8\");\n                var instrumentedSource = instrumenter.instrumentSync(source, inputPath);\n                var instrumentedFileWritePromise = fluid.promise();\n                singleFilePromises.push(instrumentedFileWritePromise);\n                fs.writeFile(outputPath, instrumentedSource, function (error) {\n                    if (error) {\n                        instrumentedFileWritePromise.reject(error);\n                    }\n                    else {\n                        instrumentedFileWritePromise.resolve();\n                    }\n                });\n\n                if (instrumentationOptions.istanbulOptions.produceSourceMap) {\n                    var sourceMap = instrumenter.lastSourceMap();\n                    var sourceMapPath = outputPath + \".map\";\n                    var sourceMapWritePromise = fluid.promise();\n                    singleFilePromises.push(sourceMapWritePromise);\n                    fs.writeFile(sourceMapPath, JSON.stringify(sourceMap, null, 2), function (error) {\n                        if (error) {\n                            sourceMapWritePromise.reject(error);\n                        }\n                        else {\n                            sourceMapWritePromise.resolve();\n                        }\n                    });\n                }\n                var singleFileSequence = fluid.promise.sequence(singleFilePromises);\n                singleFileSequence.then(instrumentationOuterPromise.resolve, instrumentationOuterPromise.reject);\n            }\n            catch (error) {\n                fluid.log(\"Error instrumenting file '\", inputPath, \"':\", error);\n                instrumentationOuterPromise.reject(error);\n            }\n\n            return instrumentationOuterPromise;\n        });\n    });\n    var sequence = fluid.promise.sequence(promises);\n    return sequence;\n};\n\n/**\n *\n * Copy a list of files to the combined \"instrumented\" output directory.  Used to interleave JSON data, uninstrumented\n * bundled third-party libraries, etc. with our instrumented source.\n *\n * @param {Array} filesToCopy - An array of paths to files to copy, relative to `baseInputPath`.\n * @param {String} baseInputPath - The base directory containing the original file (used to resolve the relative path).\n * @param {String} baseOutputPath - The base output path.\n * @return {Promise} - A `fluid.promise` that will be resolved when all files are copied or rejected if there is an error.\n *\n */\ngpii.testem.instrumenter.copyAllFiles = function (filesToCopy, baseInputPath, baseOutputPath) {\n    var resolvedBaseInputPath = fluid.module.resolvePath(baseInputPath);\n    var resolvedBaseOutputPath = fluid.module.resolvePath(baseOutputPath);\n    var promises = [];\n    fluid.each(filesToCopy, function (relativePath) {\n        promises.push(function () {\n            var fileCopyPromise = fluid.promise();\n            try {\n                var fullInputPath = path.resolve(resolvedBaseInputPath, relativePath);\n                var readStream = fs.createReadStream(fullInputPath);\n                var outputPath = path.resolve(resolvedBaseOutputPath, relativePath);\n                var outputDir = path.dirname(outputPath);\n                if (!fs.existsSync(outputDir)) {\n                    mkdirp.sync(outputDir);\n                };\n                var writeStream = fs.createWriteStream(outputPath);\n                writeStream.on(\"finish\", function () {\n                    fileCopyPromise.resolve();\n                });\n                readStream.pipe(writeStream);\n            }\n            catch (err) {\n                fileCopyPromise.reject(err);\n            }\n            return fileCopyPromise;\n        });\n    });\n    var sequence = fluid.promise.sequence(promises);\n    return sequence;\n};\n"
  ]
}